=================================================================================
Cookie工作机制：服务器发送一个Cookie让客户端保存在本地 [服务器不记录]
	
【早期用法】

						POST /cart Http1.1
						Host:shop.com
		（第一次）				
						apple=1 (请求保存一个苹果)
			客户端 ------------------------------> 服务端

			     <------------------------------- 
			     		HTTP1.1 200 ok
			     		Set-Cookie:cart="apple=1" (告知客户端记录到本地)

		Cookie文件内容：cart="apple=1"	     		

		（第二次）

						POST /cart Http1.1
						Host：shop.com
						Cookie:	cart="apple=1"

						banana="1"
		  	客户端 ------------------------------> 服务端

		  				HTTP1.1 200 ok
			     		Set-Cookie:cart="apple=1&banana=1"

		Cookie文件内容：cart="apple=1&banana=1"	     

作用：
	会话管理：登录状态、购物车、用户偏好、行为分析(用户画像)（国外网站会进行使用cookie的提示）等

=================================================================================

						POST /login Http1.1
						Host:shop.com
		（第一次）				
						username=a&password=b
			客户端 ------------------------------> 服务端  (创建会话Session id：1)

			     <------------------------------- 
			     		HTTP1.1 200 ok
			     		Set-Cookie:sessionid=1

Cookie文件内容：cart="sessionid=1"				     		


		（第二次）

						POST /user Http1.1
						Host：shop.com
						Cookie:	sessionid=1

		  	客户端 ------------------------------> 服务端 (未过期 且登录 返回用户信息)
				  <------------------------------
		  				HTTP1.1 200 ok
			     		{"id":1，"name":"zhangsan"}	


		（行为追踪）
			     		
			     		GET / Http1.1
						Host：shop.com

		  	客户端 ------------------------------> 服务端1 (追加网站来源信息)
		  		  <------------------------------
		  				HTTP1.1 200 ok
		  				Set-Cookie:client_id=123
			     		
			     		<html>
			     		<img src="http://xxxxx?from=shop.com" />

Cookie文件内容：client_id=123	

			     		GET / Http1.1
						Host：other.com
						Cookie:client_id=123

		  	客户端 ------------------------------> 服务端2 (截取from就会知道来源)
		  		  <------------------------------

		  		  		HTTP1.1 200 ok
		  				Set-Cookie:other_id=666

		  				<html>
			     		精准定位广告


Cookie文件内容：client_id=123	
			  other_id=666	  				
=================================================================================
Cookie的漏洞：
	XSS：（Cross-site scripting 跨站脚本）：HttpOnly
		
		在cookie中附加 这样本地脚本看不到，从而防止使用脚本获取cookie信息 进行跨站攻击



	XSRF: （Cross-site request forgery 跨站请求伪造）:Referer：host (代表是从哪里来的 这样银行网址可以判断进行拒绝操作)		  
		
		由于Cookie是浏览器自动携带 若访问过银行网站 https://bank.com

		用户又打开一个网址 若黑客赌你之前访问过银行 之后模拟使用https://bank.com/transfer?amount=1000000&to=banman 直接拿到cookie就能进行转账 
=================================================================================
Authorization 
	第一种---Basic:
			Authorization:Basic <username:password(Base64ed)>  

			例如： zhangsan:12345 再进行Base64 



		     			GET / Http1.1
						Host：shop.com
						Authorization: Basic emhhbmdzYW46MTIzNDU=

		  	客户端 ------------------------------> 服务端2 (截取from就会知道来源)
		  		  <------------------------------
		  		  		HTTP1.1 200 ok

		【安全方面：使用https  但Authorization会保存在本地 若保存在android手机 ROOT之后 某清理App就可以窃取】	  		  		


	第二种---Bearer: 持票人	
			Authorization:Bearer <token>

			OAuth2: 较OAuth更少的操作，且安全性并不降低




	第三方授权： 微信授权给第三方的体育App [这里第三方是体育App]
	第三方登录： 使用微信登录到体育App    [这里第三方是微信]

		OAuth2流程：

			client_id: 开发人员在开放平台注册的 微信授权给体育的APP_ID,用于微信去验证 是否注册并享有哪些权限
			client_secret: 开发人员在开放平台注册的 微信授权给体育的APP_SECRET,用于识别服务端身份 防止假身份

						（OAuth2的用途就白费了）应该是服务端持有，App自己持有是不对的，并且微信回来的token也不应该给客户端 
											否则直接使用授权码去访问微信就行 何必通过服务端 （目前做法只是为了经过服务端和公司统一派发令牌）


			Authorization code 的引入，
				把「用户确认授权」和「获取 token」两个步骤拆分开了，
				其中第二个步骤必须在申请授权方的服务器进行，因此保证了网络中的监听者拿不到真正有用的 access token。											

								【client_id】  					
					客户端  --------------------> wx.com （授权页） 

							 	  点击确定
						   <--------------------
						    Authorization code
						    	(返回授权码)

								    												  (https)
								    											oauth2/access_token 
							Authorization code 							
						   --------------------> 服务端 （证明用户愿意授权）----------------------------------->  wx.com
						   											    【client_secret] 和 Authorization code		

						   											  	
						   											  	 	       access token			   				
						   											  	<----------------------------------- 	


						   										Authorization:Bearer <token>
												 服务端 ----------------------------------------------------->
													   <-----------------------------------------------------
															{
																"token_type":"Bearer",
																"access_token":"xxxxxx",
																"refresh_token":"yyyyyy",
																"expires_time":"24298752387",
															}	
												

															POST /refresh_token http1.1
														----------------------------------------------------->

														  	{
																"refresh_token":"yyyyyy",
																"expires_time":"24298752387",
															}					  	  	
=========================================================================================================================TCTCP/IP协议族
	一系列协议组成的一个网络分层模型 （前提网络环境不稳定，若都稳定直接应用层之间通信就无需分层了）

	http：应用层； 交给下层处理											   【只要结果 Boss】

	TCP：传输层；  由于传输中有多个节点 任意中断就需要重传；一般使用分块传输来保证带宽利用率
				 关系双方通信是否可达
				 分块之后交给下层处理，收到对方确认全部块传输完毕，向上层汇报	   【只管分块 产品】
				 	       

		 UDP: 同上；不用每次重发，不关心是否对方收到
		 		   广播通信，视频通信 也是传输层			 

	IP： 网络层；对传输层透明 只管网络发送，其他的都不管；
			   上层让传输什么就传输什么，收到对方传回直接向上层汇报			  【只管寻址发送 开发leader】
				
	以太网：数据链路层；现实世界的物理连接通道（WIFI路由器，交换机等等）			  【只管网络传输 程序员】
			   

	http（发） ---------------------------------------应用层--------------------------------------> http (收)
   
     TCP      ---------------------------------------传输层-------------------------------------->  TCP 

     IP 	  ---------------------------------------网络层-------------------------------------->  IP

    以太网	  -------------------------------------数据链路层------------------------------------->  以太网
=========================================================================================================================
TCP连接建立 （三次握手）

		  		我要给你发消息
    TCP ----------------------------> TCP
        	好的，知道了，我也要给你发
        <----------------------------
  				好的，知道了
        ---------------------------->

TCP连接关闭 （四次握手）

		  		我不给你发消息
    TCP（A） ----------------------------> TCP （B）
        		 好的，知道了
	        <----------------------------


	        			.... B给A发消息 

	        		我也不给你发消息了	
	        <----------------------------
	  				好的，知道了
	        ---------------------------->



一般上网是短连接：手机上网通过运营商作为中间人访问，运营商发给手机端口服务进行上网，上网完成端口就被关闭了

     -----------------------------
     |	xiaomi					 |
     |				iphone		 |
     |		huawei				 |	
     |							 |
     |							 |	
     -----------------------------		
     		(内网)							运营商（网关）			公网（internet）

TCP长连接：     		
	场景：聊天，直播，视频，推送等 

	方式：心跳（欺骗网关不会关闭）
=========================================================================================================================
HTTPS：（http建立在SSL上的协议，SSL并非单独的协议）

	SSL：Secure Socket Layer --> TLS: Transport Layer Secure

	定义：在HTTP下增加的一个安全层，保证HTTP加密传输
	本质：在C和S之间写上一个对称密钥，进行对称加密和解密 （不使用非对称加密是因为慢，先用非对称加密拿到证书，之后使用对称加密）


	http（发） ---------------------------------------应用层--------------------------------------> http (收)
   
	 TLS      ---------------------------------------安全层-------------------------------------->  TLS

     TCP      ---------------------------------------传输层-------------------------------------->  TCP 

     IP 	  ---------------------------------------网络层-------------------------------------->  IP

    以太网	  -------------------------------------数据链路层-------------------------------------> 以太网



    第一步：客户端请求TLS连接 （通过TCP）
    第二步：服务器发回证书
    第三步：客户端验证证书
    第四步：客户端信任证书之后，同服务器协商对称密钥（使用非对称加密）
    第五步：使用对称密钥开始通信


    	1.  Client Hello ： C发给S，我要使用TLS/SSL（早期）建立连接  我支持的版本号有哪些（序列信息）
    								加密套件（Cipher Suite,即C可以接收的对称加密，非对称加密，hash算法，密钥加密的随机数A等信息）
    	
    	2.  Server Hello ： S发给C，好的，给你加密套件方案（Cipher Suite，我打算跟你使用的加密算法,密钥加密的随机数B信息）
    	
    	3.  服务器证书	 ： S发给C，给你证书(服务器有多个) 
    							包含 ①服务器host 名称等信息
									②证书签名【对服务器host、名称、证书公钥等信息进行的签名】 用来让客户端验证服务器对不对 
									③证书公钥
									④证书机构公钥和证书机构签发方信息 （使用证书机构公钥去验证签名 只能证明签名是这个机构的颁发的）
									

    							如何验证服务器签名？
    								若黑客拦截证书后 所有信息暴露 它使用一个任意私钥和公钥对 再对其他信息进行签名怎么办
    								这时候使用黑客的公钥（证书机构公钥）验证黑客的签名（证书签名）就废了

    								其实服务器证书里还有提供证书机构的签发方信息

    								⑤证书机构的签发方信息 （可以找到可靠来源 来自自己操作系统的Root证书） 
    										
    								  若自己操作系统的Root证书可以验证签名 就证明整个证书是可信任的
    								  一般方案都是需要一个中间机构（证书机构），而非直接Root去签名

    								  Root证书是操作系统官方签发的 只要浏览器和OS不被黑就是安全的
    								  点击https地址栏前面的锁可以查看证书--Root证书就是证书机构的签发方
    								  若根证书机构被黑或者腐败授权就废了（Root证书无条件信任  没有绝对的安全）


    	4. 	信任证书后，C使用服务器证书公钥加密Pre-master Secret(一个随机数)进行唯一一次【非对称加密】	
    			Pre-master Secret用于双方创建密钥的关键信息	
    	
    	5.  这时候协商对称密钥 
    			①使用 随机数A + B + Pre-master Secret + 算法 = master Secret及其其他加密需要的盐
    				虽然都是明文传输但是数学方式上可以保证算出的master Secret更安全
    			
    			②使用master Secret去计算密钥 （主要包括四个） 					进行【加密解密】
    				客户端加密密钥		（客户端发消息时加密使用）											
					服务端加密密钥		（服务端发消息时加密使用）									
					客户端Mac Secret	（客户端身份验证）							
					服务端Mac Secret （服务端身份验证）											

					由于双方都有master Secret,则C使用客户端加密密钥发消息，S使用服务端加密密钥发消息都可以解密

    				
    			③使用HMAC: Hash-based Message Authenticate Code (改良版hash)	进行【身份验证】

    					     客户端Mac Secret(盐)
    				HMAC(a) --------------------> MD5(fun(a)) ---> xx

    				C发送给S，携带xx(改良的hash值)，S收到后使用客户端Mac Secret也能转换成xx，证明消息来自客户端

    	6. Client请求使用加密通信 xxxxx
    	7. Client发送1,2,3,4步的信息通过  	客户端加密密钥	 + 	客户端Mac Secret 进行最终验证告知S验证工作结束	
   		8. Server告知Client可以加密通信了
   		9. Server发送验证工作结束

   		10.之后双方就用火星文交流了#@DSGSdfjpow-0a9s=4%23


    客户端随机数A														 客户端随机数A
    服务端随机数B														 服务端随机数B

    TLS版本															 TLS版本
    对称加密算法					服务器地址							 对称加密算法
    非对称加密算法					证书公钥								 非对称加密算法
    hash算法						证书签名								 hash算法
    								证书机构公钥
    								证书机构其他信息
    									证书机构签发方
      【客户端】 															【服务端】

    服务器证书公钥														 服务器证书私钥
Pre-master Secret(一个随机数)											Pre-master Secret
	master Secret 													master Secret	
	客户端加密密钥														客户端加密密钥
	服务端加密密钥														服务端加密密钥
	
		（盐）															（盐）
	客户端Mac Secret （hash方式身份验证）								客户端Mac Secret
	服务端Mac Secret 												服务端Mac Secret	
	
=========================================================================================================================什么时候https方式不行？
	1.用的是自签名证书 （证书一般都是挂在网站上的 有时候证书里只有公钥 客户端来验证签名而非使用根证书机构 只用于内网的https）	
	2.证书信息不全，缺乏结构
	3.手机操作系统旧，没安装最新加入的【根证书】 ，旧的根证书认为这些都不合法
	
自己手写验证